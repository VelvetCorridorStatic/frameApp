<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Simple Image-in-Frame</title>
  <style>
    :root {
      --bg: #f6f7f9;       /* page background */
      --panel: #ffffff;    /* control panel bg */
      --muted: #5f6368;    /* secondary text */
      --text: #111315;     /* primary text */
      --accent: #1a73e8;   /* buttons/slider thumb */
      --border: rgba(0,0,0,.12);
      --shadow: 0 6px 20px rgba(0,0,0,.08);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
    }
    header, footer {
      padding: 12px 16px;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      overscroll-behavior: contain;
    }
    header h1 {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: .2px;
      margin: 0;
      opacity: .9;
      color: var(--text);
    }

    /* Default (mobile): stacked layout */
    .shell { display: block; }
    main { display: grid; place-items: center; padding: 8px 16px 16px; }

    /* Stage area: no box behind the frame */
    .stage-wrap {
      width: 100%;
      max-width: 1100px;
      display: grid;
      place-items: center;
      padding: 0;             /* no padding frame box */
      border: 0;              /* no border */
      background: transparent;/* no background box */
      box-shadow: none;       /* no shadow */
      min-height: 300px;
    }
    canvas {
      max-width: 100%;
      height: auto;
      display: block;
      background: #ffffff;    /* white canvas behind your framed image */
      border-radius: 0;       /* no rounded corners */
      touch-action: pan-y;    /* allow page scroll when not manipulating the image */
    }

    /* Controls (light theme) */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
      justify-content: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      width: min(980px, 96vw);
      margin: 8px auto 0;
    }
    .controls label { font-size: 13px; color: var(--muted); }
    input[type="file"] { color: var(--muted); }
    .radio-group { display: inline-flex; gap: 8px; align-items: center; }
    .radio-group label {
      display:inline-flex; gap:6px; align-items:center;
      padding:6px 10px; border:1px solid var(--border); border-radius:10px;
      cursor:pointer; background:#fff; color: var(--text);
    }
    .radio-group input { margin: 0; }

    .slider {
      appearance: none; height: 6px; border-radius: 999px; background: #e5e7eb; outline: none; width: 160px; cursor: pointer; border: 1px solid var(--border);
    }
    .slider::-webkit-slider-thumb { appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--accent); box-shadow: 0 2px 8px rgba(26,115,232,.3); }

    .btn {
      border: 1px solid var(--border);
      background: linear-gradient(#ffffff, #f4f6f8);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 1px 0 #fff inset;
    }
    .btn:active { transform: translateY(1px); }
    .btn#download { background: linear-gradient(#e8f0fe, #dbe8fd); border-color: rgba(26,115,232,.25); }

    .hint { font-size: 12px; color: var(--muted); text-align: center; margin-top: 8px; }

    /* Desktop (≥1024px): two-pane layout */
    @media (min-width: 1024px) {
      .shell {
        display: grid;
        grid-template-columns: minmax(0,1fr) 380px;
        gap: 16px;
        width: min(1400px, 96vw);
        margin: 0 auto;
        align-items: start;
      }
      main { padding: 8px 16px 16px; }
      .stage-wrap {
        height: 100vh;          /* match window height */
        min-height: 400px;
        display: grid;
        align-content: center;
        justify-items: center;
      }
      #controls {
        position: sticky;
        top: 12px;
        max-height: calc(100vh - 24px);
        overflow: auto;
        width: 100%;
      }
      .controls {
        width: auto;
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>

  <div class="shell">
    <main id="left">
      <div class="stage-wrap" id="stageWrap">
        <canvas id="stage" width="1200" height="800" aria-label="Composition canvas"></canvas>
      </div>
    </main>
    <aside id="right">
      <header><h1>Image → Frame</h1></header>
      <section class="controls" id="controls" role="group" aria-label="Controls">
        <div>
          <label for="uploader">Upload image:</label>
          <input id="uploader" type="file" accept="image/*" />
        </div>

        <div class="radio-group" role="radiogroup" aria-label="Frame">
          <label><input type="radio" name="frame" value="frame1.webp" checked> frame1.webp</label>
          <label><input type="radio" name="frame" value="frame2.webp"> frame2.webp</label>
        </div>

        <div>
          <label for="scale">Scale</label>
          <input id="scale" class="slider" type="range" min="0.25" max="4" step="0.01" value="1" />
<span id="scaleOut" aria-live="polite">100%</span>
        </div>

        <div>
          <button id="fit" class="btn" title="Center & fit the uploaded image">Fit to view</button>
          <button id="reset" class="btn" title="Reset position & scale">Reset</button>
          <button id="download" class="btn" title="Export a PNG">Download PNG</button>
        </div>
      </section>
    </aside>
  </div>

  <footer>
    <small class="hint">Place <code>frame1.webp</code> and <code>frame2.webp</code> in the same folder as this file.</small>
  </footer>

  <script>
  // --- Elements
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const stageWrap = document.getElementById('stageWrap');
  const uploader = document.getElementById('uploader');
  const radioFrames = [...document.querySelectorAll('input[name="frame"]')];
  const scaleSlider = document.getElementById('scale');
  const scaleOut = document.getElementById('scaleOut');
  const btnFit = document.getElementById('fit');
  const btnReset = document.getElementById('reset');
  const btnDownload = document.getElementById('download');

  // --- State
  const state = {
    frameSrc: 'frame1.webp',
    frameImg: null,
    userImg: null,
    viewW: 800,
    viewH: 600,
    dpr: Math.min(window.devicePixelRatio || 1, 2),
    fitScale: 1, // NEW: baseline scale for "Fit"
    user: { x: 0, y: 0, scale: 1, isDragging: false, dragStartX: 0, dragStartY: 0, imgStartX: 0, imgStartY: 0 },
    pinch: { active: false, startDist: 0, startScale: 1, midX: 0, midY: 0 },
    pointers: new Map(),
  };

  // --- Helpers
  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.decoding = 'async';
      img.src = src;
    });
  }

  function applyDPR() {
    state.dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.style.width = state.viewW + 'px';
    canvas.style.height = state.viewH + 'px';
    canvas.width = Math.round(state.viewW * state.dpr);
    canvas.height = Math.round(state.viewH * state.dpr);
    ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0); // draw in CSS px
  }

  function layoutCanvas() {
    const desktop = window.matchMedia('(min-width: 1024px)').matches;
    const aspect = state.frameImg ? state.frameImg.width / state.frameImg.height : 1200 / 800;

    let w, h;
    if (desktop) {
      const viewportH = window.innerHeight;
      h = Math.max(400, Math.floor(viewportH));
      const idealW = Math.round(h * aspect);
      const wrapRect = stageWrap.getBoundingClientRect();
      const maxW = Math.max(320, Math.floor(wrapRect.width - 24));
      w = Math.min(idealW, maxW);
    } else {
      const maxW = Math.min(1200, Math.floor(window.innerWidth * 0.92));
      w = maxW;
      h = Math.round(w / aspect);
    }

    const oldW = state.viewW, oldH = state.viewH;
    const hadUser = !!state.userImg;
    const oldFit = hadUser ? state.fitScale : 1;

    state.viewW = w; state.viewH = h;
    applyDPR();

    if (hadUser) {
      // Recompute baseline fit for new canvas size
      const iw = state.userImg.width, ih = state.userImg.height;
      state.fitScale = Math.min(state.viewW / iw, state.viewH / ih);

      // Preserve placement (what you had), already handled by proportional scale:
      const kx = w / oldW, ky = h / oldH;
      const k = Math.min(kx, ky);
      state.user.x *= kx;
      state.user.y *= ky;
      state.user.scale *= k;

      // Sync slider to current zoom relative to the new fit
      const rel = state.user.scale / state.fitScale;
      scaleSlider.value = clamp(rel, parseFloat(scaleSlider.min), parseFloat(scaleSlider.max)).toFixed(2);
      scaleOut.textContent = `${Math.round(rel * 100)}%`;
    }

    draw();
  }

  function fitUserImage() {
    if (!state.userImg) return;
    const cw = state.viewW, ch = state.viewH;
    const iw = state.userImg.width, ih = state.userImg.height;
    const s = Math.min(cw / iw, ch / ih);
    state.fitScale = s;           // set baseline
    state.user.scale = s;         // start at "fit"
    state.user.x = (cw - iw * s) / 2;
    state.user.y = (ch - ih * s) / 2;
    scaleSlider.value = '1.00';   // 1.00 = 100% of fit
    scaleOut.textContent = '100%';
    draw();
  }

  function resetTransform() {
    if (!state.userImg) return;
    // Reset back to current fit
    const cw = state.viewW, ch = state.viewH;
    const iw = state.userImg.width, ih = state.userImg.height;
    state.fitScale = Math.min(cw / iw, ch / ih);
    state.user.scale = state.fitScale;
    state.user.x = (cw - iw * state.fitScale) / 2;
    state.user.y = (ch - ih * state.fitScale) / 2;
    scaleSlider.value = '1.00';
    scaleOut.textContent = '100%';
    draw();
  }

  function draw() {
    const { frameImg, userImg, user, viewW, viewH } = state;
    ctx.clearRect(0, 0, viewW, viewH);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, viewW, viewH);

    if (userImg) {
      const w = userImg.width * user.scale;
      const h = userImg.height * user.scale;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(userImg, user.x, user.y, w, h);
    }
    if (frameImg) {
      ctx.drawImage(frameImg, 0, 0, viewW, viewH);
    }
  }

  function hitOnUserImage(px, py) {
    if (!state.userImg) return false;
    const w = state.userImg.width * state.user.scale;
    const h = state.userImg.height * state.user.scale;
    return px >= state.user.x && py >= state.user.y && px <= state.user.x + w && py <= state.user.y + h;
  }

  // Utils
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // --- Coords & gestures
  function getCanvasPoint(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) / rect.width * state.viewW;
    const y = (clientY - rect.top) / rect.height * state.viewH;
    return { x, y };
  }
  function distance(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return Math.hypot(dx, dy);
  }

  function onPointerDown(e) {
    if (!state.userImg) return;
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // Two fingers → start pinch
    if (state.pointers.size === 2) {
      const [a, b] = [...state.pointers.values()];
      const pa = getCanvasPoint(a.x, a.y);
      const pb = getCanvasPoint(b.x, b.y);
      state.pinch.active = true;
      state.pinch.startDist = distance(pa, pb);
      state.pinch.startScale = state.user.scale;
      state.pinch.midX = (pa.x + pb.x) / 2;
      state.pinch.midY = (pa.y + pb.y) / 2;
      try { canvas.setPointerCapture(e.pointerId); } catch {}
      return;
    }

    // One finger → only start drag if finger starts on the image
    if (state.pointers.size === 1) {
      const pt = getCanvasPoint(e.clientX, e.clientY);
      if (hitOnUserImage(pt.x, pt.y)) {
        state.user.isDragging = true;
        state.user.dragStartX = pt.x;
        state.user.dragStartY = pt.y;
        state.user.imgStartX = state.user.x;
        state.user.imgStartY = state.user.y;
        try { canvas.setPointerCapture(e.pointerId); } catch {}
        e.preventDefault(); // stop page scroll while dragging image
      } else {
        state.user.isDragging = false; // allow page to scroll
      }
    }
  }

  function onPointerMove(e) {
    if (!state.userImg) return;
    if (state.pointers.has(e.pointerId)) {
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }

    if (state.pinch.active && state.pointers.size >= 2) {
      const [a, b] = [...state.pointers.values()];
      const pa = getCanvasPoint(a.x, a.y);
      const pb = getCanvasPoint(b.x, b.y);
      const d = Math.max(10, distance(pa, pb));
      let newScale = state.pinch.startScale * (d / state.pinch.startDist);
      newScale = clamp(newScale, state.fitScale * parseFloat(scaleSlider.min), state.fitScale * parseFloat(scaleSlider.max));

      const mx = state.pinch.midX, my = state.pinch.midY;
      const imgX = (mx - state.user.x) / state.user.scale;
      const imgY = (my - state.user.y) / state.user.scale;
      state.user.x = mx - imgX * newScale;
      state.user.y = my - imgY * newScale;
      state.user.scale = newScale;

      // Sync slider
      const rel = state.user.scale / state.fitScale;
      scaleSlider.value = rel.toFixed(2);
      scaleOut.textContent = `${Math.round(rel * 100)}%`;

      e.preventDefault();
      draw();
      return;
    }

    if (state.user.isDragging) {
      const pt = getCanvasPoint(e.clientX, e.clientY);
      const dx = pt.x - state.user.dragStartX;
      const dy = pt.y - state.user.dragStartY;
      state.user.x = state.user.imgStartX + dx;
      state.user.y = state.user.imgStartY + dy;
      e.preventDefault();
      draw();
    }
  }

  function onPointerUp(e) {
    state.pointers.delete(e.pointerId);
    if (state.pointers.size < 2) state.pinch.active = false;
    if (state.pointers.size === 0) state.user.isDragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  }

  // --- Init
  (async function init() {
    state.frameImg = await loadImage(state.frameSrc);
    layoutCanvas();
  })().catch(console.error);

  // --- Events
  radioFrames.forEach(r => r.addEventListener('change', async (e) => {
    state.frameSrc = e.target.value;
    state.frameImg = await loadImage(state.frameSrc);
    const prevW = state.viewW;
    layoutCanvas();
    if (state.userImg && Math.abs(state.viewW - prevW) > 2) draw();
  }));

  uploader.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = await loadImage(url);
    state.userImg = img;
    fitUserImage();
  });

  // Slider now controls zoom RELATIVE to Fit (1.00 = 100%)
  scaleSlider.addEventListener('input', (e) => {
    if (!state.userImg) return;
    const rel = parseFloat(e.target.value); // 0.25..4
    const newScale = clamp(rel, parseFloat(scaleSlider.min), parseFloat(scaleSlider.max)) * state.fitScale;

    // scale around image center
    const iw = state.userImg.width * state.user.scale;
    const ih = state.userImg.height * state.user.scale;
    const cx = state.user.x + iw / 2;
    const cy = state.user.y + ih / 2;

    const iw2 = state.userImg.width * newScale;
    const ih2 = state.userImg.height * newScale;
    state.user.x = cx - iw2 / 2;
    state.user.y = cy - ih2 / 2;
    state.user.scale = newScale;

    scaleOut.textContent = `${Math.round(rel * 100)}%`;
    draw();
  });

  // Desktop wheel zoom (syncs slider)
  canvas.addEventListener('wheel', (e) => {
    if (!state.userImg) return;
    e.preventDefault();
    const { offsetX, offsetY, deltaY } = e;
    const factor = Math.pow(1.0015, -deltaY);
    let newScale = state.user.scale * factor;
    const minAbs = state.fitScale * parseFloat(scaleSlider.min);
    const maxAbs = state.fitScale * parseFloat(scaleSlider.max);
    newScale = clamp(newScale, minAbs, maxAbs);

    const x = offsetX, y = offsetY;
    const imgX = (x - state.user.x) / state.user.scale;
    const imgY = (y - state.user.y) / state.user.scale;
    state.user.x = x - imgX * newScale;
    state.user.y = y - imgY * newScale;

    state.user.scale = newScale;
    const rel = newScale / state.fitScale;
    scaleSlider.value = rel.toFixed(2);
    scaleOut.textContent = `${Math.round(rel * 100)}%`;
    draw();
  }, { passive: false });

  canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
  canvas.addEventListener('pointermove', onPointerMove, { passive: false });
  window.addEventListener('pointerup', onPointerUp, { passive: false });

  // Resize debounce
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(layoutCanvas, 60);
  });

  // Buttons
  btnFit.addEventListener('click', fitUserImage);
  btnReset.addEventListener('click', resetTransform);
  btnDownload.addEventListener('click', downloadPNG);

  // Cross-browser PNG download
  function downloadPNG() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    if (isIOS) {
      // Open in a new tab so the user can long-press/save
      const dataURL = canvas.toDataURL('image/png');
      const w = window.open('', '_blank');
      if (w) {
        w.document.write('<meta name="viewport" content="width=device-width,initial-scale=1"/>');
        w.document.write('<title>framed.png</title>');
        w.document.write('<img src="' + dataURL + '" style="max-width:100%;height:auto;display:block;margin:0 auto" />');
      } else {
        // Fallback: navigate current tab
        window.location.href = dataURL;
      }
      return;
    }
    if (canvas.toBlob) {
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'framed.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png');
    } else {
      // Older fallback
      const a = document.createElement('a');
      a.href = canvas.toDataURL('image/png');
      a.download = 'framed.png';
      a.click();
    }
  }
</script>
</body>
</html>