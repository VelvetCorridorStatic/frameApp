<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Framer — Image in Frame</title>
  <style>
    :root {
      --bg: #f6f7f9;       /* page background */
      --panel: #ffffff;    /* control panel bg */
      --muted: #5f6368;    /* secondary text */
      --text: #111315;     /* primary text */
      --accent: #1a73e8;   /* buttons/slider thumb */
      --border: rgba(0,0,0,.12);
      --shadow: 0 6px 20px rgba(0,0,0,.08);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
    }

    /* Default (mobile): stacked layout */
    .shell { display: block; }
    main { display: grid; place-items: center; padding: 8px 16px 16px; }

    /* Stage area: no box behind the frame */
    .stage-wrap {
      width: 100%;
      max-width: 1100px;
      display: grid;
      place-items: center;
      padding: 0;
      border: 0;
      background: transparent;
      box-shadow: none;
      min-height: 300px;
    }
    canvas {
      max-width: 100%;
      height: auto;
      display: block;
      background: #ffffff;    /* white canvas behind your framed image */
      border-radius: 0;
      touch-action: pan-y;    /* allow page scroll when not manipulating the image */
    }

    /* Controls (light theme) */
    .controls {
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 14px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      width: min(980px, 96vw);
      margin: 8px auto 0;
    }
    .group { display:flex; flex-direction:column; gap:6px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .controls label { font-size: 12px; color: var(--muted); }
    .value { min-width: 56px; text-align: right; font-variant-numeric: tabular-nums; color: var(--muted); }

    input[type="file"] { color: var(--muted); }
    .radio-group { display: inline-flex; gap: 8px; align-items: center; flex-wrap:wrap; }
    .radio-group label {
      display:inline-flex; gap:6px; align-items:center;
      padding:6px 10px; border:1px solid var(--border); border-radius:10px;
      cursor:pointer; background:#fff; color: var(--text);
    }
    .radio-group input { margin: 0; }

    .slider {
      appearance: none; height: 6px; border-radius: 999px; background: #e5e7eb; outline: none; width: 220px; cursor: pointer; border: 1px solid var(--border);
    }
    .slider::-webkit-slider-thumb { appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--accent); box-shadow: 0 2px 8px rgba(26,115,232,.3); }
    .mini-check { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; }

    .corner-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    .corner-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #fafbff; box-shadow: inset 0 1px 0 #fff; }
    .corner-title { font-size: 12px; font-weight: 600; color: var(--text); margin-bottom: 4px; }
    .mini-row { display: flex; align-items: center; gap: 8px; }
    .mini-row .slider { width: 180px; }
    .mini-row .value { min-width: 48px; }

    .btn {
      border: 1px solid var(--border);
      background: linear-gradient(#ffffff, #f4f6f8);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 1px 0 #fff inset;
    }
    .btn:active { transform: translateY(1px); }
    .btn#download { background: linear-gradient(#e8f0fe, #dbe8fd); border-color: rgba(26,115,232,.25); }

    /* Mobile: keep stage visible while scrolling controls */
    @media (max-width: 1023px) {
      main {
        position: sticky;
        top: 0;
        z-index: 2;
        background: var(--bg);
      }
    }

    /* Desktop (≥1024px): two-pane layout */
    @media (min-width: 1024px) {
      .shell {
        display: grid;
        grid-template-columns: minmax(0,1fr) 380px;
        gap: 16px;
        width: min(1400px, 96vw);
        margin: 0 auto;
        align-items: start;
      }
      main { padding: 8px 16px 16px; }
      .stage-wrap {
        height: 100vh;          /* match window height */
        min-height: 400px;
        display: grid;
        align-content: center;
        justify-items: center;
      }
      #controls {
        position: sticky;
        top: 12px;
        max-height: calc(100vh - 24px);
        overflow: auto;
        width: 100%;
      }
      .controls {
        width: auto;
      }
      .button-row { display:flex; gap:10px; flex-wrap:wrap; }
    }
  </style>
</head>
<body>

  <div class="shell">
    <main id="left">
      <div class="stage-wrap" id="stageWrap">
        <canvas id="stage" width="1200" height="800" aria-label="Composition canvas"></canvas>
      </div>
    </main>
    <aside id="right">
      <section class="controls" id="controls" role="group" aria-label="Controls">
        <div class="group">
          <label for="uploader">Upload image</label>
          <input id="uploader" type="file" accept="image/*" />
        </div>

        <div class="group">
  <label for="frameSelect">Frame</label>
  <select id="frameSelect" style="padding:6px 10px;border:1px solid var(--border);border-radius:10px;background:#fff;width:100%;font-size:13px;">
    <option value="ckt-template-120x190" data-full-dark="ckt-template-120x190-full-dark.png" data-full-light="ckt-template-120x190-full-light.png">ckt-template-120x190 (full only)</option>
    <option value="ckt-template-150x120" data-full-dark="ckt-template-150x120-full-dark.png" data-full-light="ckt-template-150x120-full-light.png">ckt-template-150x120 (full only)</option>
    <option value="ckt-template-160x135" data-full-dark="ckt-template-160x135-full-dark.png" data-full-light="ckt-template-160x135-full-light.png">ckt-template-160x135 (full only)</option>
    <option value="ckt-template-215x165" data-full-dark="ckt-template-215x165-full-dark.png" data-full-light="ckt-template-215x165-full-light.png" data-close-dark="ckt-template-215x165-close-dark.png" data-close-light="ckt-template-215x165-close-light.png" selected>ckt-template-215x165 (full, close)</option>
    <option value="ckt-template-50x40" data-full-dark="ckt-template-50x40-full-dark.png" data-full-light="ckt-template-50x40-full-light.png" data-close-dark="ckt-template-50x40-close-dark.png" data-close-light="ckt-template-50x40-close-light.png">ckt-template-50x40 (full, close)</option>
    <option value="ckt-template-55x55" data-full-light="ckt-template-55x55-full-light.png" data-close-light="ckt-template-55x55-close-light.png" data-crop-light="ckt-template-55x55-crop-light.png">ckt-template-55x55 (full, close, crop)</option>
    <option value="ckt-template-60x50" data-full-dark="ckt-template-60x50-full-dark.png" data-full-light="ckt-template-60x50-full-light.png" data-close-dark="ckt-template-60x50-close-dark.png" data-close-light="ckt-template-60x50-close-light.png">ckt-template-60x50 (full, close)</option>
    <option value="ckt-template-80x70" data-full-light="ckt-template-80x70-full-light.png" data-close-light="ckt-template-80x70-close-light.png" data-crop-light="ckt-template-80x70-crop-light.png">ckt-template-80x70 (full, close, crop)</option>
    <option value="ckt-template-90x80" data-full-light="ckt-template-90x80-full-light.png" data-close-light="ckt-template-90x80-close-light.png" data-crop-light="ckt-template-90x80-crop-light.png">ckt-template-90x80 (full, close, crop)</option>
    <option value="ckt-template-90x90" data-full-dark="ckt-template-90x90-full-dark.png" data-full-light="ckt-template-90x90-full-light.png" data-close-dark="ckt-template-90x90-close-dark.png" data-close-light="ckt-template-90x90-close-light.png" data-crop-dark="ckt-template-90x90-crop-dark.png" data-crop-light="ckt-template-90x90-crop-light.png">ckt-template-90x90 (full, close, crop)</option>
    <option value="ckt-aquarell-landscape-01" data-full-light="ckt-aquarell-landscape-01 light.png">ckt-aquarell-landscape-01 (full, light only)</option>
    <option value="ckt-aquarell-portrait-01" data-full-light="ckt-aquarell-portrait-01 light.png">ckt-aquarell-portrait-01 (full, light only)</option>
  </select>
</div>
<div class="group">
  <label>Frame color</label>
  <div class="row">
    <label class="mini-check"><input id="frameToneDark" type="checkbox" checked /> Dark</label>
    <label class="mini-check"><input id="frameToneLight" type="checkbox" /> Light</label>
  </div>
</div>
<div class="group">
  <label>Frame crop</label>
  <div class="row">
    <label class="mini-check"><input id="frameVarFull" type="checkbox" checked /> Full</label>
    <label class="mini-check"><input id="frameVarCrop" type="checkbox" /> Cropped</label>
    <label class="mini-check"><input id="frameVarClose" type="checkbox" /> Close</label>
  </div>
</div>



        <div class="group">
          <label for="scale">Zoom</label>
          <div class="row">
            <input id="scale" class="slider" type="range" min="0.25" max="4" step="0.01" value="1" />
            <span id="scaleOut" class="value" aria-live="polite">100%</span>
          </div>
        </div>

        <div class="group">
          <label>Pan</label>
          <div class="row">
            <span style="width:36px;color:var(--muted)">X</span>
            <input id="panX" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
            <span id="panXOut" class="value" aria-live="polite">0 px</span>
          </div>
          <div class="row">
            <span style="width:36px;color:var(--muted)">Y</span>
            <input id="panY" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
            <span id="panYOut" class="value" aria-live="polite">0 px</span>
          </div>
        </div>

        <div class="group">
          <label>Corner offsets (px)</label>
          <div class="corner-grid">
            <div class="corner-card">
              <div class="corner-title">Top Left</div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">X</span>
                <input id="tlx" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="tlxOut" class="value" aria-live="polite">0</span>
              </div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">Y</span>
                <input id="tly" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="tlyOut" class="value" aria-live="polite">0</span>
              </div>
            </div>
            <div class="corner-card">
              <div class="corner-title">Top Right</div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">X</span>
                <input id="trx" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="trxOut" class="value" aria-live="polite">0</span>
              </div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">Y</span>
                <input id="try" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="tryOut" class="value" aria-live="polite">0</span>
              </div>
            </div>
            <div class="corner-card">
              <div class="corner-title">Bottom Right</div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">X</span>
                <input id="brx" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="brxOut" class="value" aria-live="polite">0</span>
              </div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">Y</span>
                <input id="bry" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="bryOut" class="value" aria-live="polite">0</span>
              </div>
            </div>
            <div class="corner-card">
              <div class="corner-title">Bottom Left</div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">X</span>
                <input id="blx" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="blxOut" class="value" aria-live="polite">0</span>
              </div>
              <div class="mini-row">
                <span style="width:22px;color:var(--muted)">Y</span>
                <input id="bly" class="slider" type="range" min="-2000" max="2000" step="1" value="0" />
                <span id="blyOut" class="value" aria-live="polite">0</span>
              </div>
            </div>
          </div>
        </div>

        <div class="group">
          <label for="exposure">Exposure</label>
          <div class="row">
            <input id="exposure" class="slider" type="range" min="-2" max="2" step="0.01" value="0" />
            <span id="exposureOut" class="value" aria-live="polite">0.00 EV</span>
          </div>
        </div>

        <div class="group">
          <label for="contrast">Contrast</label>
          <div class="row">
            <input id="contrast" class="slider" type="range" min="-50" max="50" step="1" value="0" />
            <span id="contrastOut" class="value" aria-live="polite">0</span>
          </div>
        </div>

        <div class="group">
          <label for="saturation">Saturation</label>
          <div class="row">
            <input id="saturation" class="slider" type="range" min="0" max="2" step="0.01" value="1" />
            <span id="saturationOut" class="value" aria-live="polite">100%</span>
          </div>
        </div>

        <div class="group">
          <label for="temperature">Temperature</label>
          <div class="row">
            <input id="temperature" class="slider" type="range" min="-100" max="100" step="1" value="0" />
            <span id="temperatureOut" class="value" aria-live="polite">0</span>
          </div>
        </div>

        <div class="group">
          <label for="tint">Tint</label>
          <div class="row">
            <input id="tint" class="slider" type="range" min="-100" max="100" step="1" value="0" />
            <span id="tintOut" class="value" aria-live="polite">0</span>
          </div>
        </div>

        <div class="button-row">
          <button id="fit" class="btn" title="Center & fit">Fit to view</button>
          <button id="reset" class="btn" title="Reset pan/zoom">Reset</button>
          <button id="download" class="btn" title="Export a PNG">Download PNG</button>
        </div>
      </section>
    </aside>
  </div>

  <script>
    // --- Elements
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const stageWrap = document.getElementById('stageWrap');
    const uploader = document.getElementById('uploader');
    const frameSelect = document.getElementById('frameSelect');
    const frameToneDark = document.getElementById('frameToneDark');
    const frameToneLight = document.getElementById('frameToneLight');
    const frameVarFull = document.getElementById('frameVarFull');
    const frameVarCrop = document.getElementById('frameVarCrop');
    const frameVarClose = document.getElementById('frameVarClose');


    const scaleSlider = document.getElementById('scale');
    const scaleOut = document.getElementById('scaleOut');
    const panX = document.getElementById('panX');
    const panXOut = document.getElementById('panXOut');
    const panY = document.getElementById('panY');
    const panYOut = document.getElementById('panYOut');

    const cornerControls = {
      tl: { x: document.getElementById('tlx'), y: document.getElementById('tly'), outX: document.getElementById('tlxOut'), outY: document.getElementById('tlyOut') },
      tr: { x: document.getElementById('trx'), y: document.getElementById('try'), outX: document.getElementById('trxOut'), outY: document.getElementById('tryOut') },
      br: { x: document.getElementById('brx'), y: document.getElementById('bry'), outX: document.getElementById('brxOut'), outY: document.getElementById('bryOut') },
      bl: { x: document.getElementById('blx'), y: document.getElementById('bly'), outX: document.getElementById('blxOut'), outY: document.getElementById('blyOut') },
    };

    const exposureSlider = document.getElementById('exposure');
    const exposureOut = document.getElementById('exposureOut');

    const contrastSlider = document.getElementById('contrast');
    const contrastOut = document.getElementById('contrastOut');

    const saturationSlider = document.getElementById('saturation');
    const saturationOut = document.getElementById('saturationOut');

    const temperatureSlider = document.getElementById('temperature');
    const temperatureOut = document.getElementById('temperatureOut');

    const tintSlider = document.getElementById('tint');
    const tintOut = document.getElementById('tintOut');

    const btnFit = document.getElementById('fit');
    const btnReset = document.getElementById('reset');
    const btnDownload = document.getElementById('download');

    // --- State
    const state = {
      frameBase: 'ckt-template-215x165',
      frameTone: 'dark',
      frameSrc: '',
      frameVariant: 'full',
      frameImg: null,
      userOrigImg: null, // original <img>
      userImg: null,     // processed offscreen canvas
      viewW: 800,
      viewH: 600,
      dpr: Math.min(window.devicePixelRatio || 1, 2),
      fitScale: 1,       // baseline for Zoom = 1.0
      cornerOffsets: {
        tl: { x: 0, y: 0 },
        tr: { x: 0, y: 0 },
        br: { x: 0, y: 0 },
        bl: { x: 0, y: 0 },
      },
      cornerStrength: 0.1, // scale down slider influence
      cornerRange: 2000,
      needsPlacement: false,
      panStrength: 0.1,
      // Adjustments
      exposureStops: 0,
      contrastAmt: 0,      // -50..+50 (linear contrast)
      saturationMul: 1,    // 0..2
      temperatureAmt: 0,   // -100..+100 (cool..warm)
      tintAmt: 0,          // -100..+100 (green..magenta)
      mobileViewportH: window.innerHeight, // locked mobile height to prevent scroll-bar resize jitter
      lastViewportW: window.innerWidth,
      lastViewportH: window.innerHeight,
      // Interaction
      processingTimer: null,
      user: { x: 0, y: 0, scale: 1, isDragging: false, dragStartX: 0, dragStartY: 0, imgStartX: 0, imgStartY: 0 },
      pinch: { active: false, startDist: 0, startScale: 1, midX: 0, midY: 0 },
      pointers: new Map(),
    };

    // --- Helpers
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.decoding = 'async';
        img.src = src;
      });
    }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpPoint(p1, p2, t) { return { x: lerp(p1.x, p2.x, t), y: lerp(p1.y, p2.y, t) }; }
    function quadPoint(tl, tr, bl, br, u, v) {
      const top = lerpPoint(tl, tr, u);
      const bottom = lerpPoint(bl, br, u);
      return lerpPoint(top, bottom, v);
    }

    function applyDPR() {
      state.dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.style.width = state.viewW + 'px';
      canvas.style.height = state.viewH + 'px';
      canvas.width = Math.round(state.viewW * state.dpr);
      canvas.height = Math.round(state.viewH * state.dpr);
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0); // draw in CSS px
    }

    function getQuad() {
      if (!state.userImg) return null;
      const w = state.userImg.width * state.user.scale;
      const h = state.userImg.height * state.user.scale;
      const { x, y } = state.user;
      const c = state.cornerOffsets;
      const k = state.cornerStrength || 1;
      return {
        tl: { x: x + c.tl.x * k, y: y + c.tl.y * k },
        tr: { x: x + w + c.tr.x * k, y: y + c.tr.y * k },
        br: { x: x + w + c.br.x * k, y: y + h + c.br.y * k },
        bl: { x: x + c.bl.x * k, y: y + h + c.bl.y * k },
      };
    }

    function getQuadBounds(quad) {
      const xs = [quad.tl.x, quad.tr.x, quad.br.x, quad.bl.x];
      const ys = [quad.tl.y, quad.tr.y, quad.br.y, quad.bl.y];
      return {
        minX: Math.min(...xs), maxX: Math.max(...xs),
        minY: Math.min(...ys), maxY: Math.max(...ys),
      };
    }

    function getQuadCenter(quad) {
      return {
        x: (quad.tl.x + quad.tr.x + quad.br.x + quad.bl.x) / 4,
        y: (quad.tl.y + quad.tr.y + quad.br.y + quad.bl.y) / 4,
      };
    }

    function inflateTriangle(tri, amount = 0.75) {
      const cx = (tri[0].x + tri[1].x + tri[2].x) / 3;
      const cy = (tri[0].y + tri[1].y + tri[2].y) / 3;
      return tri.map(p => {
        const dx = p.x - cx, dy = p.y - cy;
        const len = Math.hypot(dx, dy) || 1;
        const k = (len + amount) / len;
        return { x: cx + dx * k, y: cy + dy * k };
      });
    }

    function resetCorners() {
      state.cornerOffsets.tl.x = state.cornerOffsets.tl.y =
      state.cornerOffsets.tr.x = state.cornerOffsets.tr.y =
      state.cornerOffsets.br.x = state.cornerOffsets.br.y =
      state.cornerOffsets.bl.x = state.cornerOffsets.bl.y = 0;
      syncCornerUI();
    }

    function scaleCornerOffsets(kx, ky) {
      const c = state.cornerOffsets;
      c.tl.x *= kx; c.tr.x *= kx; c.br.x *= kx; c.bl.x *= kx;
      c.tl.y *= ky; c.tr.y *= ky; c.br.y *= ky; c.bl.y *= ky;
    }

    function syncCornerBounds() {
      const range = Math.max(800, Math.round(Math.max(state.viewW, state.viewH) * 0.75));
      state.cornerRange = range;
      Object.values(cornerControls).forEach(ctrl => {
        ctrl.x.min = -range; ctrl.x.max = range;
        ctrl.y.min = -range; ctrl.y.max = range;
      });
    }

    function syncCornerUI() {
      const c = state.cornerOffsets;
      cornerControls.tl.x.value = String(Math.round(c.tl.x));
      cornerControls.tl.y.value = String(Math.round(c.tl.y));
      cornerControls.tr.x.value = String(Math.round(c.tr.x));
      cornerControls.tr.y.value = String(Math.round(c.tr.y));
      cornerControls.br.x.value = String(Math.round(c.br.x));
      cornerControls.br.y.value = String(Math.round(c.br.y));
      cornerControls.bl.x.value = String(Math.round(c.bl.x));
      cornerControls.bl.y.value = String(Math.round(c.bl.y));

      const k = state.cornerStrength || 1;
      cornerControls.tl.outX.textContent = `${Math.round(c.tl.x * k)}`;
      cornerControls.tl.outY.textContent = `${Math.round(c.tl.y * k)}`;
      cornerControls.tr.outX.textContent = `${Math.round(c.tr.x * k)}`;
      cornerControls.tr.outY.textContent = `${Math.round(c.tr.y * k)}`;
      cornerControls.br.outX.textContent = `${Math.round(c.br.x * k)}`;
      cornerControls.br.outY.textContent = `${Math.round(c.br.y * k)}`;
      cornerControls.bl.outX.textContent = `${Math.round(c.bl.x * k)}`;
      cornerControls.bl.outY.textContent = `${Math.round(c.bl.y * k)}`;
    }

    function syncPanUI() {
      const k = state.panStrength || 1;
      const minX = parseFloat(panX.min), maxX = parseFloat(panX.max);
      const minY = parseFloat(panY.min), maxY = parseFloat(panY.max);
      panX.value = String(Math.round(clamp(state.user.x / k, minX, maxX)));
      panY.value = String(Math.round(clamp(state.user.y / k, minY, maxY)));
      panXOut.textContent = `${Math.round(state.user.x)} px`;
      panYOut.textContent = `${Math.round(state.user.y)} px`;
    }

    function updateToneUI(lightAvailable, tone) {
      const useLight = tone === 'light' && lightAvailable;
      frameToneLight.disabled = !lightAvailable;
      frameToneLight.checked = useLight;
      frameToneDark.checked = !useLight;
    }

    function updateVariantUI(variantAvailability, variant) {
      const desired = variant || 'full';
      const hasFull = !!variantAvailability.full;
      const hasCrop = !!variantAvailability.crop;
      const hasClose = !!variantAvailability.close;

      frameVarFull.disabled = !hasFull;
      frameVarCrop.disabled = !hasCrop;
      frameVarClose.disabled = !hasClose;

      let chosen = desired;
      if (desired === 'full' && !hasFull) chosen = hasCrop ? 'crop' : hasClose ? 'close' : null;
      if (desired === 'crop' && !hasCrop) chosen = hasFull ? 'full' : hasClose ? 'close' : null;
      if (desired === 'close' && !hasClose) chosen = hasFull ? 'full' : hasCrop ? 'crop' : null;
      if (!chosen) return;

      frameVarFull.checked = chosen === 'full';
      frameVarCrop.checked = chosen === 'crop';
      frameVarClose.checked = chosen === 'close';

      return chosen;
    }

    function resolveFrameSource(base, desiredTone, desiredVariant) {
      const option = [...frameSelect.options].find(o => o.value === base) || frameSelect.selectedOptions[0];
      if (!option) return null;
      const tonePref = desiredTone === 'light' ? ['Light', 'Dark'] : ['Dark', 'Light'];
      const variantPref = desiredVariant ? [desiredVariant] : [];
      ['full', 'crop', 'close'].forEach(v => { if (!variantPref.includes(v)) variantPref.push(v); });

      let chosenTone = desiredTone;
      let chosenVariant = desiredVariant || 'full';
      let src = '';

      for (const toneKey of tonePref) {
        for (const variant of variantPref) {
          const key = `${variant}${toneKey}`;
          if (option.dataset[key]) {
            src = option.dataset[key];
            chosenTone = toneKey === 'Light' ? 'light' : 'dark';
            chosenVariant = variant;
            break;
          }
        }
        if (src) break;
      }

      if (!src) return null;

      const variantAvailability = {
        full: !!option.dataset.fullLight || !!option.dataset.fullDark,
        crop: !!option.dataset.cropLight || !!option.dataset.cropDark,
        close: !!option.dataset.closeLight || !!option.dataset.closeDark,
      };
      const lightAvailable = !!option.dataset.fullLight || !!option.dataset.cropLight || !!option.dataset.closeLight;

      return { src, tone: chosenTone, variant: chosenVariant, lightAvailable, variantAvailability };
    }

    async function applyFrameChange() {
      const desiredTone = frameToneLight.checked ? 'light' : 'dark';
      const desiredVariant = frameVarCrop.checked ? 'crop' : frameVarClose.checked ? 'close' : 'full';
      const base = frameSelect.value;
      const resolved = resolveFrameSource(base, desiredTone, desiredVariant);
      if (!resolved) return;
      state.frameBase = base;
      state.frameTone = resolved.tone;
      state.frameSrc = resolved.src;
      state.frameVariant = resolved.variant;
      updateToneUI(resolved.lightAvailable, state.frameTone);
      const finalVariant = updateVariantUI(resolved.variantAvailability, state.frameVariant);
      if (finalVariant && finalVariant !== state.frameVariant) state.frameVariant = finalVariant;
      state.frameImg = await loadImage(state.frameSrc);
      layoutCanvas();
    }

    // Compute canvas CSS size from frame aspect and viewport
    function layoutCanvas() {
      const desktop = window.matchMedia('(min-width: 1024px)').matches;
      const aspect = state.frameImg ? state.frameImg.width / state.frameImg.height : 1200 / 800;

      let w, h;
      if (desktop) {
        const viewportH = window.innerHeight;
        h = Math.max(400, Math.floor(viewportH));
        const idealW = Math.round(h * aspect);
        const wrapRect = stageWrap.getBoundingClientRect();
        const maxW = Math.max(320, Math.floor(wrapRect.width - 24));
        w = Math.min(idealW, maxW);
      } else {
        const maxW = Math.min(1200, Math.floor(window.innerWidth * 0.92));
        const maxH = Math.floor(state.mobileViewportH * 0.6);
        w = maxW;
        h = Math.round(w / aspect);
        if (h > maxH) {
          h = maxH;
          w = Math.round(h * aspect);
        }
      }

      const oldW = state.viewW, oldH = state.viewH;
      const hadUser = !!state.userImg;

      state.viewW = w; state.viewH = h;
      applyDPR();

      if (hadUser) {
        // Recompute fit baseline for new canvas size
        const iw = state.userImg.width, ih = state.userImg.height;
        state.fitScale = Math.min(state.viewW / iw, state.viewH / ih);

        // Preserve placement proportionally
        const kx = w / oldW, ky = h / oldH;
        const k = Math.min(kx, ky);
        state.user.x *= kx;
        state.user.y *= ky;
        state.user.scale *= k;
        scaleCornerOffsets(kx, ky);

        // Sync slider to current zoom relative to new fit
        const rel = state.user.scale / state.fitScale;
        scaleSlider.value = clamp(rel, parseFloat(scaleSlider.min), parseFloat(scaleSlider.max)).toFixed(2);
        scaleOut.textContent = `${Math.round(rel * 100)}%`;
      }

      syncCornerBounds();
      clampPosition();
      syncCornerUI();
      syncPanUI();
      requestDraw();
    }

    function fitUserImage() {
      if (!state.userImg) return;
      const cw = state.viewW, ch = state.viewH;
      const iw = state.userImg.width, ih = state.userImg.height;
      const s = Math.min(cw / iw, ch / ih);
      state.fitScale = s;           // set baseline
      state.user.scale = s;         // start at "fit"
      state.user.x = (cw - iw * s) / 2;
      state.user.y = (ch - ih * s) / 2;
      resetCorners();
      syncCornerBounds();
      state.needsPlacement = false;
      scaleSlider.value = '1.00';   // 1.00 = 100% of fit
      scaleOut.textContent = '100%';
      clampPosition();
      syncCornerUI();
      syncPanUI();
      requestDraw();
    }

    function resetTransform() {
      if (!state.userImg) return;
      const cw = state.viewW, ch = state.viewH;
      const iw = state.userImg.width, ih = state.userImg.height;
      state.fitScale = Math.min(cw / iw, ch / ih);
      state.user.scale = state.fitScale;
      state.user.x = (cw - iw * state.fitScale) / 2;
      state.user.y = (ch - ih * state.fitScale) / 2;
      resetCorners();
      syncCornerBounds();
      state.needsPlacement = false;
      scaleSlider.value = '1.00';
      scaleOut.textContent = '100%';
      clampPosition();
      syncCornerUI();
      syncPanUI();
      requestDraw();
    }

    let drawPending = false;
    function requestDraw() {
      if (drawPending) return;
      drawPending = true;
      requestAnimationFrame(() => {
        drawPending = false;
        draw();
      });
    }

    function draw() {
      const { frameImg, userImg, viewW, viewH } = state;
      ctx.clearRect(0, 0, viewW, viewH);
      ctx.fillStyle = '#ffffff'; // white canvas bg
      ctx.fillRect(0, 0, viewW, viewH);

      if (userImg) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'medium';
        drawWarpedUserImage();
      }
      if (frameImg) {
        ctx.drawImage(frameImg, 0, 0, viewW, viewH);
      }
    }

    function setTransformForTriangle(srcTri, dstTri) {
      const [s0, s1, s2] = srcTri;
      const [d0, d1, d2] = dstTri;
      const denom = s0.x * (s1.y - s2.y) - s0.y * (s1.x - s2.x) + s1.x * s2.y - s2.x * s1.y || 1e-6;
      const a = d0.x * (s1.y - s2.y) - d1.x * (s0.y - s2.y) + d2.x * (s0.y - s1.y);
      const b = d0.x * (s2.x - s1.x) + d1.x * (s0.x - s2.x) + d2.x * (s1.x - s0.x);
      const c = d0.x * (s1.x * s2.y - s2.x * s1.y) + d1.x * (s2.x * s0.y - s0.x * s2.y) + d2.x * (s0.x * s1.y - s1.x * s0.y);
      const d = d0.y * (s1.y - s2.y) - d1.y * (s0.y - s2.y) + d2.y * (s0.y - s1.y);
      const e = d0.y * (s2.x - s1.x) + d1.y * (s0.x - s2.x) + d2.y * (s1.x - s0.x);
      const f = d0.y * (s1.x * s2.y - s2.x * s1.y) + d1.y * (s2.x * s0.y - s0.x * s2.y) + d2.y * (s0.x * s1.y - s1.x * s0.y);
      const dpr = state.dpr || 1;
      ctx.setTransform(a / denom * dpr, d / denom * dpr, b / denom * dpr, e / denom * dpr, c / denom * dpr, f / denom * dpr);
    }

    function drawTriangle(img, s0, s1, s2, d0, d1, d2) {
      const inflated = inflateTriangle([d0, d1, d2], 0.75);
      const id0 = inflated[0], id1 = inflated[1], id2 = inflated[2];
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(id0.x, id0.y);
      ctx.lineTo(id1.x, id1.y);
      ctx.lineTo(id2.x, id2.y);
      ctx.closePath();
      ctx.clip();
      setTransformForTriangle([s0, s1, s2], [id0, id1, id2]);
      ctx.drawImage(img, 0, 0);
      ctx.restore();
    }

    function drawWarpedUserImage() {
      const quad = getQuad();
      const img = state.userImg;
      if (!quad || !img) return;

      const cols = 12, rows = 12;
      for (let i = 0; i < cols; i++) {
        const u0 = i / cols, u1 = (i + 1) / cols;
        const q0Top = lerpPoint(quad.tl, quad.tr, u0);
        const q0Bot = lerpPoint(quad.bl, quad.br, u0);
        const q1Top = lerpPoint(quad.tl, quad.tr, u1);
        const q1Bot = lerpPoint(quad.bl, quad.br, u1);

        for (let j = 0; j < rows; j++) {
          const v0 = j / rows, v1 = (j + 1) / rows;
          const p00 = lerpPoint(q0Top, q0Bot, v0);
          const p01 = lerpPoint(q0Top, q0Bot, v1);
          const p10 = lerpPoint(q1Top, q1Bot, v0);
          const p11 = lerpPoint(q1Top, q1Bot, v1);

          const sx0 = u0 * img.width, sx1 = u1 * img.width;
          const sy0 = v0 * img.height, sy1 = v1 * img.height;

          drawTriangle(img,
            { x: sx0, y: sy0 }, { x: sx1, y: sy0 }, { x: sx1, y: sy1 },
            p00, p10, p11);
          drawTriangle(img,
            { x: sx0, y: sy0 }, { x: sx1, y: sy1 }, { x: sx0, y: sy1 },
            p00, p11, p01);
        }
      }
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
    }

    function hitOnUserImage(px, py) {
      if (!state.userImg) return false;
      const quad = getQuad();
      if (!quad) return false;
      const triA = [quad.tl, quad.tr, quad.br];
      const triB = [quad.tl, quad.br, quad.bl];
      const pointInTri = (p, a, b, c) => {
        const sign = (p, a, b) => (p.x - b.x) * (a.y - b.y) - (a.x - b.x) * (p.y - b.y);
        const b1 = sign(p, a, b) < 0, b2 = sign(p, b, c) < 0, b3 = sign(p, c, a) < 0;
        return (b1 === b2) && (b2 === b3);
      };
      return pointInTri({ x: px, y: py }, ...triA) || pointInTri({ x: px, y: py }, ...triB);
    }

    // --- Position helpers (new)
    function clampPosition() {
      // Keep some looseness so you can freely distort outside the frame
    }

    // --- Color processing (one pass, debounced)
    function scheduleProcess() {
      clearTimeout(state.processingTimer);
      state.processingTimer = setTimeout(processImage, 120);
    }

    function processImage() {
      if (!state.userOrigImg) return;

      const src = state.userOrigImg;
      const w = src.naturalWidth || src.width;
      const h = src.naturalHeight || src.height;

      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const octx = off.getContext('2d');
      octx.drawImage(src, 0, 0, w, h);

      const imgData = octx.getImageData(0, 0, w, h);
      const d = imgData.data;

      // Params
      const exposure = Math.pow(2, state.exposureStops);          // 2^EV in linear
      const contrast = Math.pow(2, state.contrastAmt / 50);       // perceptual-ish contrast multiplier
      const sat = state.saturationMul;                            // 0..2
      // Temperature/Tint as gentle channel multipliers
      const t = state.temperatureAmt / 100;  // -1..+1
      const ti = state.tintAmt / 100;        // -1..+1
      const rMul = 1 + 0.15 * t - 0.05 * ti; // warmer adds red; magenta reduces green
      const gMul = 1 + 0.15 * ti;            // tint swings green channel
      const bMul = 1 - 0.15 * t - 0.05 * ti; // cooler adds blue

      // sRGB <-> Linear helpers
      const srgbToLin = v => {
        v = v / 255;
        return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
      };
      const linToSrgb = v => {
        v = Math.max(0, Math.min(1, v));
        return v <= 0.0031308 ? 255 * v * 12.92 : 255 * (1.055 * Math.pow(v, 1/2.4) - 0.055);
      };

      for (let i = 0; i < d.length; i += 4) {
        // to linear
        let rl = srgbToLin(d[i]);
        let gl = srgbToLin(d[i+1]);
        let bl = srgbToLin(d[i+2]);

        // exposure
        rl *= exposure; gl *= exposure; bl *= exposure;

        // temperature/tint (channel multipliers)
        rl *= rMul; gl *= gMul; bl *= bMul;

        // saturation in linear: mix with luminance
        const Y = 0.2126*rl + 0.7152*gl + 0.0722*bl;
        rl = Y + (rl - Y) * sat;
        gl = Y + (gl - Y) * sat;
        bl = Y + (bl - Y) * sat;

        // contrast around 0.5 (linear midpoint-ish)
        rl = (rl - 0.5) * contrast + 0.5;
        gl = (gl - 0.5) * contrast + 0.5;
        bl = (bl - 0.5) * contrast + 0.5;

        // to sRGB
        d[i]   = linToSrgb(rl);
        d[i+1] = linToSrgb(gl);
        d[i+2] = linToSrgb(bl);
        // alpha unchanged
      }

      octx.putImageData(imgData, 0, 0);
      state.userImg = off;

      // If first build, fit to view
      if (state.needsPlacement) {
        fitUserImage();
      } else {
        clampPosition();
        syncCornerBounds();
        syncCornerUI();
        syncPanUI();
        requestDraw();
      }
    }

    // --- Coords & gestures
    function getCanvasPoint(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) / rect.width * state.viewW;
      const y = (clientY - rect.top) / rect.height * state.viewH;
      return { x, y };
    }
    function distance(p1, p2) { const dx = p1.x - p2.x, dy = p1.y - p2.y; return Math.hypot(dx, dy); }

    function onPointerDown(e) {
      if (!state.userImg) return;
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (state.pointers.size === 2) {
        const [a, b] = [...state.pointers.values()];
        const pa = getCanvasPoint(a.x, a.y);
        const pb = getCanvasPoint(b.x, b.y);
        state.pinch.active = true;
        state.pinch.startDist = distance(pa, pb);
        state.pinch.startScale = state.user.scale;
        state.pinch.midX = (pa.x + pb.x) / 2;
        state.pinch.midY = (pa.y + pb.y) / 2;
        try { canvas.setPointerCapture(e.pointerId); } catch {}
        return;
      }

      if (state.pointers.size === 1) {
        const pt = getCanvasPoint(e.clientX, e.clientY);
        if (hitOnUserImage(pt.x, pt.y)) {
          state.user.isDragging = true;
          state.user.dragStartX = pt.x;
          state.user.dragStartY = pt.y;
          state.user.imgStartX = state.user.x;
          state.user.imgStartY = state.user.y;
          try { canvas.setPointerCapture(e.pointerId); } catch {}
          e.preventDefault();
        } else {
          state.user.isDragging = false;
        }
      }
    }

    function onPointerMove(e) {
      if (!state.userImg) return;
      if (state.pointers.has(e.pointerId)) {
        state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      }

      if (state.pinch.active && state.pointers.size >= 2) {
        const [a, b] = [...state.pointers.values()];
        const pa = getCanvasPoint(a.x, a.y);
        const pb = getCanvasPoint(b.x, b.y);
        const d = Math.max(10, distance(pa, pb));
        let newScale = state.pinch.startScale * (d / state.pinch.startDist);

        const minAbs = state.fitScale * parseFloat(scaleSlider.min);
        const maxAbs = state.fitScale * parseFloat(scaleSlider.max);
        newScale = clamp(newScale, minAbs, maxAbs);

        const mx = state.pinch.midX, my = state.pinch.midY;
        const imgX = (mx - state.user.x) / state.user.scale;
        const imgY = (my - state.user.y) / state.user.scale;
        const factor = newScale / state.user.scale;
        scaleCornerOffsets(factor, factor);
        state.user.x = mx - imgX * newScale;
        state.user.y = my - imgY * newScale;
        state.user.scale = newScale;

        const rel = newScale / state.fitScale;
        scaleSlider.value = rel.toFixed(2);
        scaleOut.textContent = `${Math.round(rel * 100)}%`;

        e.preventDefault();
        clampPosition();
        syncCornerBounds();
        syncCornerUI();
        syncPanUI();
        requestDraw();
        return;
      }

      if (state.user.isDragging) {
        const pt = getCanvasPoint(e.clientX, e.clientY);
        const dx = pt.x - state.user.dragStartX;
        const dy = pt.y - state.user.dragStartY;
        state.user.x = state.user.imgStartX + dx;
        state.user.y = state.user.imgStartY + dy;
        e.preventDefault();
        clampPosition();
        syncCornerUI();
        syncPanUI();
        requestDraw();
      }
    }

    function onPointerUp(e) {
      state.pointers.delete(e.pointerId);
      if (state.pointers.size < 2) state.pinch.active = false;
      if (state.pointers.size === 0) state.user.isDragging = false;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
    }

    // --- Init
    (async function init() {
      await applyFrameChange();
    })().catch(console.error);

    // --- Events
    frameSelect.addEventListener('change', () => { applyFrameChange(); });
    frameToneDark.addEventListener('change', () => {
      if (frameToneDark.checked) frameToneLight.checked = false;
      else if (!frameToneLight.checked) frameToneDark.checked = true;
      applyFrameChange();
    });
    frameToneLight.addEventListener('change', () => {
      if (frameToneLight.disabled) { frameToneLight.checked = false; return; }
      if (frameToneLight.checked) frameToneDark.checked = false;
      else if (!frameToneDark.checked) frameToneDark.checked = true;
      applyFrameChange();
    });
    frameVarFull.addEventListener('change', () => {
      if (frameVarFull.disabled) { frameVarFull.checked = false; return; }
      if (frameVarFull.checked) {
        frameVarCrop.checked = false;
        frameVarClose.checked = false;
      } else if (!frameVarCrop.checked && !frameVarClose.checked) {
        frameVarFull.checked = true;
      }
      applyFrameChange();
    });
    frameVarCrop.addEventListener('change', () => {
      if (frameVarCrop.disabled) { frameVarCrop.checked = false; return; }
      if (frameVarCrop.checked) {
        frameVarFull.checked = false;
        frameVarClose.checked = false;
      } else if (!frameVarFull.checked && !frameVarClose.checked) {
        frameVarFull.checked = true;
      }
      applyFrameChange();
    });
    frameVarClose.addEventListener('change', () => {
      if (frameVarClose.disabled) { frameVarClose.checked = false; return; }
      if (frameVarClose.checked) {
        frameVarFull.checked = false;
        frameVarCrop.checked = false;
      } else if (!frameVarFull.checked && !frameVarCrop.checked) {
        frameVarFull.checked = true;
      }
      applyFrameChange();
    });

    uploader.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = await loadImage(url);
      state.userOrigImg = img;
      state.needsPlacement = true;
      resetCorners();

      // Build first processed version
      processImage();
    });

    // Zoom slider (relative to Fit)
    scaleSlider.addEventListener('input', (e) => {
      if (!state.userImg) return;
      const rel = parseFloat(e.target.value); // 0.25..4
      const newScale = clamp(rel, parseFloat(scaleSlider.min), parseFloat(scaleSlider.max)) * state.fitScale;

      const quadBefore = getQuad();
      const centerBefore = quadBefore ? getQuadCenter(quadBefore) : { x: state.viewW / 2, y: state.viewH / 2 };
      const factor = newScale / state.user.scale;
      state.user.scale = newScale;
      scaleCornerOffsets(factor, factor);
      const quadAfter = getQuad();
      if (quadAfter) {
        const centerAfter = getQuadCenter(quadAfter);
        state.user.x += centerBefore.x - centerAfter.x;
        state.user.y += centerBefore.y - centerAfter.y;
      }

      scaleOut.textContent = `${Math.round(rel * 100)}%`;
      clampPosition();
      syncCornerBounds();
      syncCornerUI();
      syncPanUI();
      requestDraw();
    });

    // Corner sliders
    Object.entries(cornerControls).forEach(([key, ctrl]) => {
      ctrl.x.addEventListener('input', (e) => {
        if (!state.userImg) return;
        state.cornerOffsets[key].x = parseInt(e.target.value, 10) || 0;
        clampPosition();
        syncCornerUI();
        syncPanUI();
        requestDraw();
      });
      ctrl.y.addEventListener('input', (e) => {
        if (!state.userImg) return;
        state.cornerOffsets[key].y = parseInt(e.target.value, 10) || 0;
        clampPosition();
        syncCornerUI();
        syncPanUI();
        requestDraw();
      });
    });

    // Pan sliders
    panX.addEventListener('input', (e) => {
      if (!state.userImg) return;
      const k = state.panStrength || 1;
      state.user.x = (parseInt(e.target.value, 10) || 0) * k;
      clampPosition();
      syncPanUI();
      requestDraw();
    });
    panY.addEventListener('input', (e) => {
      if (!state.userImg) return;
      const k = state.panStrength || 1;
      state.user.y = (parseInt(e.target.value, 10) || 0) * k;
      clampPosition();
      syncPanUI();
      requestDraw();
    });

    // Color controls (debounced)
    exposureSlider.addEventListener('input', (e) => {
      state.exposureStops = parseFloat(e.target.value) || 0;
      exposureOut.textContent = `${state.exposureStops.toFixed(2)} EV`;
      scheduleProcess();
    });
    contrastSlider.addEventListener('input', (e) => {
      state.contrastAmt = parseInt(e.target.value, 10) || 0;
      contrastOut.textContent = `${state.contrastAmt}`;
      scheduleProcess();
    });
    saturationSlider.addEventListener('input', (e) => {
      state.saturationMul = parseFloat(e.target.value) || 1;
      saturationOut.textContent = `${Math.round(state.saturationMul * 100)}%`;
      scheduleProcess();
    });
    temperatureSlider.addEventListener('input', (e) => {
      state.temperatureAmt = parseInt(e.target.value, 10) || 0;
      temperatureOut.textContent = `${state.temperatureAmt}`;
      scheduleProcess();
    });
    tintSlider.addEventListener('input', (e) => {
      state.tintAmt = parseInt(e.target.value, 10) || 0;
      tintOut.textContent = `${state.tintAmt}`;
      scheduleProcess();
    });

    // Desktop wheel zoom (syncs slider)
    canvas.addEventListener('wheel', (e) => {
      if (!state.userImg) return;
      e.preventDefault();
      const { offsetX, offsetY, deltaY } = e;
      const factor = Math.pow(1.0015, -deltaY);
      let newScale = state.user.scale * factor;
      const minAbs = state.fitScale * parseFloat(scaleSlider.min);
      const maxAbs = state.fitScale * parseFloat(scaleSlider.max);
      newScale = clamp(newScale, minAbs, maxAbs);

      const x = offsetX, y = offsetY;
      const imgX = (x - state.user.x) / state.user.scale;
      const imgY = (y - state.user.y) / state.user.scale;
      const scaleFactor = newScale / state.user.scale;
      scaleCornerOffsets(scaleFactor, scaleFactor);
      state.user.x = x - imgX * newScale;
      state.user.y = y - imgY * newScale;

      state.user.scale = newScale;
      const rel = newScale / state.fitScale;
      scaleSlider.value = rel.toFixed(2);
      scaleOut.textContent = `${Math.round(rel * 100)}%`;
      clampPosition();
      syncCornerBounds();
      syncCornerUI();
      syncPanUI();
      requestDraw();
    }, { passive: false });

    canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
    canvas.addEventListener('pointermove', onPointerMove, { passive: false });
    window.addEventListener('pointerup', onPointerUp, { passive: false });

    // Resize debounce
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        const desktop = window.matchMedia('(min-width: 1024px)').matches;
        const widthChanged = window.innerWidth !== state.lastViewportW;

        // On phones, ignore pure height changes caused by browser chrome show/hide while scrolling.
        if (!desktop && !widthChanged) {
          state.lastViewportH = window.innerHeight;
          return;
        }

        if (!desktop) state.mobileViewportH = window.innerHeight;
        state.lastViewportW = window.innerWidth;
        state.lastViewportH = window.innerHeight;
        layoutCanvas();
      }, 60);
    });

    // Buttons
    btnFit.addEventListener('click', fitUserImage);
    btnReset.addEventListener('click', resetTransform);
    btnDownload.addEventListener('click', downloadPNG);

    // Cross-browser PNG download
    function downloadPNG() {
      try { canvas.toDataURL('image/png'); } catch (err) {
        alert('Export blocked in file:// mode. Please run via a local server (e.g., python3 -m http.server).');
        return;
      }
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (isIOS) {
        const dataURL = canvas.toDataURL('image/png');
        const w = window.open('', '_blank');
        if (w) {
          w.document.write('<meta name="viewport" content="width=device-width,initial-scale=1"/>' );
          w.document.write('<title>framed.png</title>');
          w.document.write('<img src="' + dataURL + '" style="max-width:100%;height:auto;display:block;margin:0 auto" />');
        } else {
          window.location.href = dataURL;
        }
        return;
      }
      if (canvas.toBlob) {
        canvas.toBlob((blob) => {
          if (!blob) { alert('Export failed (possibly blocked by browser).'); return; }
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'framed.png';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        }, 'image/png');
      } else {
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = 'framed.png';
        a.click();
      }
    }
  </script>
</body>
</html>
